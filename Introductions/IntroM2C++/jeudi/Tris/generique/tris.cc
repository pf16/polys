// Tables en generaltemplate<class T>Table<T>::Table (int n){//  cerr << "Creation d'un tableau de longueur " << n << endl;  Table<T>::longueur = n;   nom = "";  valeurs = new T[n];  if (Table<T>::valeurs == 0) {cerr << "Plus de memoire" << endl; exit(0);}}template<class T>T& Table<T>::operator[] (int n) {  if ((n < 0) || (n >= Table<T>::longueur))    {      cerr << "Acces incorrect a l'element d'indice " << n << endl;      exit(0);    }  return Table<T>::valeurs[n];}template <class T>void Table<T>::hasard (void){  for (int i = 0; i < Table<T>::longueur; i++) Table<T>::valeurs[i] = rand() / (T)RAND_MAX;}template <class T>int Table<T>::triee (void){  for (int i = 1; i < Table<T>::longueur; i++) if (Table<T>::valeurs[i-1] > Table<T>::valeurs[i]) return 0;  return 1;}template <class T>void Table<T>::teste(){  hasard();  cout << nom << " " << flush;//  cout << *this;  clock_t depart = clock();  tri();  cout << (clock() - depart) / (float)CLOCKS_PER_SEC << endl;//  cout << *this;  if (!triee()) cout << "Erreur...";}// Bullestemplate <class T>void BubbleTable<T>::tri(){  for (int n = Table<T>::longueur; --n;)    for (int i = 0; i < n; i++)      if (Table<T>::valeurs[i] > Table<T>::valeurs[i + 1])      {        T x = Table<T>::valeurs[i];        Table<T>::valeurs[i] = Table<T>::valeurs[i + 1];        Table<T>::valeurs[i + 1] = x;      }}// Selectiontemplate <class T>void SelectTable<T>::tri(){  int i, j, n;  for (n = Table<T>::longueur; --n;)  {    T x = Table<T>::valeurs[i = n];    for(j = 0; j < n; j++)      if (Table<T>::valeurs[j] > x) x = Table<T>::valeurs[i = j];    Table<T>::valeurs[i] = Table<T>::valeurs[n];    Table<T>::valeurs[n] = x;   }}// Insertiontemplate <class T>void InsertTable<T>::tri(){  for(int i = 1; i < Table<T>::longueur; i++)  {    T x = Table<T>::valeurs[i];    int j;    for (j = i; j && (Table<T>::valeurs[j - 1] > x); j--)      Table<T>::valeurs[j] = Table<T>::valeurs[j - 1];    Table<T>::valeurs[j] = x;  }}// Shelltemplate <class T>void ShellTable<T>::tri(){  int h = 1;  while (h <= Table<T>::longueur) h = 3 * h + 1;  while (h /= 3)    for(int i = h; i < Table<T>::longueur; i++)    {      T x = Table<T>::valeurs[i];      int j;      for (j = i; (j >= h) && (Table<T>::valeurs[j - h] > x); j -= h)	Table<T>::valeurs[j] = Table<T>::valeurs[j - h];      Table<T>::valeurs[j] = x;    }}// Tastemplate <class T>void HeapTable<T>::sift(int l, int r){  T x = Table<T>::valeurs[l];  for(int j = 2 * l + 1; j < r; l = j, j = 2 * l + 1)  {    if ((j + 1 < r) && (Table<T>::valeurs[j] < Table<T>::valeurs[j + 1])) j++;    if (Table<T>::valeurs[j] <= x) break;    Table<T>::valeurs[l] = Table<T>::valeurs[j];  }  Table<T>::valeurs[l] = x;}template <class T>void HeapTable<T>::tri(){  for (int n = Table<T>::longueur / 2; n--;) sift(n, Table<T>::longueur);  for (int n = Table<T>::longueur; --n;)  {    T x = Table<T>::valeurs[0];    Table<T>::valeurs[0] = Table<T>::valeurs[n];    Table<T>::valeurs[n] = x;    sift(0, n);  }}// Tri rapidetemplate <class T>void QuickTable<T>::quick(int l, int r){  while (r - l > 1)  {    T x = Table<T>::valeurs[(l + r) / 2];    int i, j;    for(i = l, j = r - 1; i <= j; i++, j--)    {      while (Table<T>::valeurs[i] < x) i++;      while (Table<T>::valeurs[j] > x) j--;      if (i > j) break;      T y = Table<T>::valeurs[i]; Table<T>::valeurs[i] = Table<T>::valeurs[j]; Table<T>::valeurs[j] = y;    }    if (r - i > j + 1 - l)      {quick(l, j + 1); l = i;}    else      {quick(i, r); r = j + 1;}  }}template <class T>void QuickTable<T>::tri() {quick (0, Table<T>::longueur);}